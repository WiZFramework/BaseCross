<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>BaseCrossドキュメント(2017年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．シンプルバージョンサンプル(Dx11版)</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>００８．頂点色とテクスチャの合成(Dx11版)</h3>
　このサンプルは<b>SimplSample008</b>というディレクトリに含まれます。<br />
　<b>BaseCrossDx11.sln</b>というソリューションを開くと<b>Dx11版</b>が起動します。<br />
<br />
　実行結果は以下のような画面が出ます。
<p>&nbsp;</p>
<img src="img/0008a.png" width="80%"/>
<p>図0008a</p>
<p>&nbsp;</p>
<br/>
　動画は以下になります。
<p>&nbsp;</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/pbWG_6KsiVk?rel=0" frameborder="0" allowfullscreen></iframe>
<p>&nbsp;</p>
<h3>【サンプルのポイント】</h3>
　今項のサンプルのポイントは<b>複数のシェーダによる、複数の描画</b>のサンプルです。今項のサンプルには、シェーダは2種類含まれます。１つは前項までと同じ<b>VertexPositionTexture型</b>を持ったオブジェクトの描画です。中心の流れるテクスチャですが、これは前項とかわりません。そしてあたらしく背景の壁に<b>VertexPositionColorTexture型</b>の頂点を持ったオブジェクトを描画します。<br />
　これらを実装するのに<b>Dx12版</b>と<b>Dx11版</b>で実装方法を変えています。<b>Dx12版</b>については、<b>描画クラス</b>を階層的に作成し、それぞれの描画をそれらのクラスに任せます。<b>Dx11版</b>については、それぞれのオブジェクトで、べたに描画します。<br />
　当然<b>Dx12版</b>のような描画方法のほうが<b>オブジェクト指向</b>なのですが、<b>Dx11版</b>でも<b>Dx12版</b>にならって描画クラスを作成してみると、勉強になると思います。<br />
<br />
<h3>【共通解説】</h3>
　Dx12、Dx11両方に共通なのは<b>シェーダー</b>です。<b>DxSharedプロジェクト</b>内に<b>シェーダファイル</b>というフィルタがあり、そこに記述されてます。<br />
　今回使用するシェーダは<b>頂点シェーダとピクセルシェーダ</b>です。２種類のセットがあります。<b>VertexPositionTexture型</b>の頂点を持つもの用と<b>VertexPositionColorTexture型</b>のものです。<b>コンスタントバッファ</b>の2種類あります。<br />
<br />
<h3>【Dx11版解説】</h3>
　<b>BaseCrossDx11.sln</b>を開くと、<b>BaseCrossDx11</b>というメインプロジェクトがあります。この中の<b>Character.h/cpp</b>が主な記述個所になります。<br />
<br />
<h4>■初期化■</h4>
　<b>Dx11版</b>の初期化は、<b>Dx12版</b>のようにリソース初期化はありません。頂点バッファを作成し、スケール、位置などを初期化します。<br />
　その際、背景の壁は<b>VertexPositionColorTexture型</b>になります。<br />
<br />
<h4>■更新処理■</h4>
　背景の壁は更新処理はありません。<br />
　流れるテクスチャは頂点バッファを<b>マップ</b>して、バックアップを展開しながら変更します。これは前項と同じです。<br />
<br />
<h4>■描画処理■</h4>
　描画処理は、<b>Dx11版</b>は<b>Dx12版</b>のような<b>描画クラス</b>は持っていません。オブジェクトごとに描画してます。これは、明らかに効率が悪いです。新しいオブジェクトを作るたびに<b>描画処理</b>を記述する形です。<br />
　ですので、ぜひ<b>Dx12版</b>のように<b>描画クラス</b>を作成して実装してみましょう。階層化にしなくても、まずは前項（Dx11版）のように、クラス化するだけでも汎用的になります。<br />
<br />
<h3>【まとめ】</h3>
　今回は<b>シェーダの違うオブジェクト</b>を同居させる場合の、ヒントになるようなサンプルになってます。表現は前項とほぼ同じなので、比べてみると違いが判ると思います。<br />
　また、ここで知ってほしいのは<b>プログラム実装は一通りではない</b>ということです。描画処理１つとっても、クラスの設計や関数の書き方で、効率の良しあしが決まります。せっかくC++という自由度が高い言語を扱っているので、テンプレート、仮想関数など。C++の機能をふんだんに使って実装を試みましょう。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_07.html">前へ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_09.html">次へ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
